##------- Source from Fun_SClineager_v2.0.R: do not edit by hand


logit <- function(x, thres){
  x[x < thres] <- thres
  x[x > 1 - thres] <- 1 - thres
  return(log(x / (1 - x)))
}
sigmoid <- function(x){
  1 - 1/(exp(x) + 1)
}

#' @name sclineager_internal
#' @title The Gibbs sampler for SClineager
#' @description Perform the MCMC sampling to estimate parameters in SClineager.
#' @param mutations_mat (Data) The variant allele frequency (VAF) matrix, whose rows are mutations and columns are samples. Each value is in [0,1] and NA value is for unobservable cells.
#' @param coverage_mat (Data)  The total sequencing coverage matrix, whose rows are mutations and columns are samples. Each value is positive real number and NA value is for unobservable cells.
#' @param max_iter See \link{run_sclineager}.
#' @param vaf_offset See \link{run_sclineager}.
#' @param dfreedom See \link{run_sclineager}.
#' @param psi See \link{run_sclineager}.
#' @param control See \link{run_sclineager}.
#' @param save See \link{run_sclineager}.
#' @return A list with components:
#' \item{genotype_mat}{See \link{run_sclineager}.}
#' \item{genotype_mat_all}{See \link{run_sclineager}.}
#' \item{genotype_mat_orig}{See \link{run_sclineager}.}
#' \item{sigma}{See \link{run_sclineager}.}
#' \item{sigma_all}{See \link{run_sclineager}.}
#' \item{k_mat}{See \link{run_sclineager}.}
#' \item{loglike}{See \link{run_sclineager}.}
#' @examples
#' # See the github page https://github.com/inmybrain/SClineager.
#' @seealso \link{run_sclineager}
#' @importFrom MCMCpack riwish
#' @export
sclineager_internal <- function(mutations_mat,
                                coverage_mat,
                                max_iter,
                                vaf_offset,
                                dfreedom,
                                psi,
                                control = NULL,
                                save = FALSE) {
  
  # mutations_mat = res_data$mutations_mat_obs
  # coverage_mat = res_data$coverage_mat_obs
  # max_iter = 100
  # vaf_offset = 0.01
  # dfreedom = ncol(res_data$mutations_mat_obs)
  # psi = diag(10, ncol(res_data$mutations_mat_obs))
  # psi = NULL
  # control = NULL
  
  ########  set up environment  #################
  # control parameter for penalization
  if (is.null(control))
  {
    a=1
    b=0.5
    c=1
    d=20
    e=0.4
  }else
  {
    a=control$a
    b=control$b
    c=control$c
    d=control$d
    e=control$e
  }
  # transform VAF
  transform_mat <- logit(mutations_mat, vaf_offset)
  
  ########  initializaton  #############
  k_mat=a/(coverage_mat)^b*(c+d*(abs(mutations_mat-0.5)>e))
  mu=rowMeans(transform_mat, na.rm=T)
  
  sigma = riwish(dfreedom, psi)
  colnames(sigma)=rownames(sigma)=colnames(k_mat)
  
  ########  iterations  ############
  res_gibbs <- sclineager_gibbs(psi = psi,
                               k_mat = k_mat,
                               transform_mat = transform_mat,
                               mu = mu,
                               dfreedom = dfreedom,
                               sigma = sigma,
                               max_iter = max_iter, 
                               save = save)
  
  ######  wrap up  ###############
  genotype_mat <- res_gibbs$genotype_mat
  rownames(genotype_mat) <- rownames(mutations_mat)
  colnames(genotype_mat) <- colnames(mutations_mat)
  
  sigma <- res_gibbs$sigma
  
  if(save){
    genotype_mat_all <- lapply(1:max_iter, function(i) res_gibbs$genotype_mat_all[,,i])
    sigma_all <- lapply(1:max_iter, function(i) res_gibbs$sigma_all[,,i])
  } else{
    genotype_mat_all <- NULL
    sigma_all <- NULL
  }
  genotype_mat_all <- lapply(genotype_mat_all, sigmoid)
  genotype_mat <- sigmoid(genotype_mat)
  
  # return results
  results = list(
    genotype_mat = genotype_mat,
    genotype_mat_orig = mutations_mat,
    sigma = sigma,
    genotype_mat_all = genotype_mat_all,
    sigma_all = sigma_all,
    k_mat = k_mat,
    loglike = res_gibbs$loglike
  )
  return(results)
}



# file_in="~/projects/lineage/data/CML/summary/K562/cleaned.RData"
# folder="~/iproject/lineage" # 
# categories=c("chrM","synonymous SNV","nonsynonymous SNV","UTR5") # 
# max_iter=1000 # maximum iterations to run
# mask_genes=c() # mutations in these genes will not be considered
# vaf_offset=0.01 # 
# dfreedom=1 # degrees of freedom above number of cells, must be a non-negative integer
# psi # prior matrix for the IW distribution, if \code{NULL}, will be set to a diagonal matrix 
# control # control parameters for kmat 
#' @name run_sclineager
#' @title An wrapper function for running SClineager
#' @description This function wraps the main function \link{sclineager_internal} to process data and return outputs.
#' @param file_in A path pointing the input file of the .RData file generated by \link{read_sclineager}.
#' . It must have a list named "results" with components "runinfo", "mutations_mat", "annotation", and "coverage_mat".
#' @param folder A folder at which outputs are saved. If it does not exist, it will be automatically created.
#' @param categories A character vector consisting of any combination of ``frameshift substitution'', ``nonframeshift substitution'', ``nonsynonymous SNV'', ``synonymous SNV'', ``splicing'', ``UTR5'', ``UTR3'', ``stopgain'', and ``stoploss''.
#' @param max_iter The number of posterior samples. Half of samples are discarded as burn-in steps.
#' @param keep_genes (Optional) A character vector of genes. These genes will only be considered. This can be useful for, for example, limiting the estimation to only the genes that are known to be abundantly expressed in all or the majority of the sequenced cells
#' @param mask_genes (Optional) A character vector of genes. Genes in this vector will be masked from the analyses. It is probably a good idea to mask all HLA genes from the analysis.
#' @param vaf_offset A small number (e.g. 1e-2) for converting VAF to logit VAF.
#' @param dfreedom (Hyperparameter) the degrees of freedom used in inverse Wishart distribution of \code{psi}. Should be larger than \code{ncol(mutations_mat)-1}.
#' @param skip_common For the variants in consideration, if this flag is set to TRUE, the variants that are common in the human population (esp6500siv2_all>0.01) will be skipped.
#' @param psi (Hyperparameter) covariance matrix of VAF across samples. If \code{NULL} (default), it will be set to an identity matrix.
#' @param control Control parameters for determining the variance function relating the observed VAF to the true VAF (see Details). If \code{NULL} (default), then a=1, b=0.5, c=1, d=20, e=0.4.
#' @param save Logical. If TRUE, posterior samples are saved and returned. Default is \code{FALSE}.
#' @return ``imputation_results.pdf'' and ``results.RData'' are saved in \code{folder}. The .RData file contains a list with components (also returned):
#' \item{genotype_mat}{(Parameter) an estimated VAF matrix, obtained by averaging last half of posterior samples.}
#' \item{genotype_mat_all}{A list of posterior samples for VAF. \code{NULL} is returned if \code{save} is \code{FALSE}.}
#' \item{genotype_mat_orig}{Same as \code{mutations_mat}, but contains the raw VAF data.}
#' \item{sigma}{(Parameter) an estimated covariance matrix of VAF across samples, obtained by averaging last half of posterior samples.}
#' \item{sigma_all}{A list of posterior samples for a covariance matrix.  \code{NULL} is returned if \code{save} is \code{FALSE}.}
#' \item{k_mat}{A matrix whose entry is a variance function computed by empirical estimates.}
#' \item{loglike}{A vector of posterior likelihoods.}
#' \item{runinfo}{Same as \code{runinfo} in the input, but trimmed to contain only cells that appeared in \code{mutations_mat}, in the same order.}
#' \item{annotation}{Annotation information of the variants in \code{mutations_mat}.}
#' @details The formula for the variance function is 
#' \eqn{k_mat = \frac{a (c + d (abs(\code{mutations_mat} - 0.5) > e)}{\code{coverage_mat}^b}/}}
#' where arithmetic operations are defined element-wisely.
#' @examples
#' # See the github page https://github.com/inmybrain/SClineager.
#' @importFrom gplots heatmap.2
#' @export
run_sclineager<-function(file_in,folder,categories,max_iter, keep_genes = "all", mask_genes = NULL, vaf_offset,
                         dfreedom,skip_common,psi=NULL,control=NULL, save = FALSE)
{
  ########  set up environment  #################
  # load data
  load(file_in)
  runinfo=results$runinfo
  mutations_mat=results$mutations_mat
  annotation=results$annotation
  coverage_mat=results$coverage_mat
  
  # filter by sd
  keep=apply(mutations_mat,1,function(x) max(x,na.rm=T)-min(x,na.rm=T)>0.1)
  mutations_mat=mutations_mat[keep,]
  annotation=annotation[keep,]
  coverage_mat=coverage_mat[keep,]
  
  # filter by keep_genes (in) and mask_genes (out)
  if(keep_genes == "all"){
    keep = !(annotation$Gene.refGene %in% mask_genes)
  } else{
    keep = (annotation$Gene.refGene %in% keep_genes) & (!(annotation$Gene.refGene %in% mask_genes))
  }
  mutations_mat=mutations_mat[keep,]
  annotation=annotation[keep,]
  coverage_mat=coverage_mat[keep,]
  
  # filter by annotation
  if (!("all" %in% categories))
  {
    keep=annotation$ExonicFunc.refGene %in% categories
    mutations_mat=mutations_mat[keep,]
    annotation=annotation[keep,]
    coverage_mat=coverage_mat[keep,]
  }
  
  # skip common mutations?
  if (skip_common)
  {
    keep=annotation$esp6500siv2_all<=0.01
    mutations_mat=mutations_mat[keep,]
    annotation=annotation[keep,]
    coverage_mat=coverage_mat[keep,]
  }
  
  runinfo=runinfo[colnames(mutations_mat),]
  
  if(is.null(psi)){
    psi=diag(10, nrow = ncol(mutations_mat))
  }
  # SClineage internal function
  res_scl <- sclineager_internal(mutations_mat = mutations_mat,
                                 coverage_mat = coverage_mat,
                                 max_iter = max_iter,
                                 vaf_offset = vaf_offset,
                                 dfreedom = dfreedom,
                                 psi = psi,
                                 control = control,
                                 save = save)
  
  # plot
  cat("Wrap up\n")
  pdf(paste(folder,"/imputation_results.pdf",sep=""),width=15,height=10)
  cellnote=mutations_mat
  cellnote[]=""
  cellnote[is.na(mutations_mat)]="x"
  heatmap.2(mutations_mat,na.color="grey",trace="none",Rowv=F,Colv=F,dendrogram="none")
  heatmap.2(res_scl$genotype_mat,trace="none",Rowv=F,Colv=F,dendrogram="none",
            cellnote=cellnote,notecex=0.3,notecol=NA)
  heatmap.2(res_scl$genotype_mat,trace="none",Rowv=T,Colv=T,dendrogram="none",
            cellnote=cellnote,notecex=0.3,notecol=NA)
  dev.off()
  
  # return results
  results = list(
    genotype_mat = res_scl$genotype_mat,
    genotype_mat_orig = mutations_mat,
    sigma = res_scl$sigma,
    genotype_mat_all = res_scl$genotype_mat_all,
    sigma_all = res_scl$sigma_all,
    loglike = res_scl$loglike,
    runinfo = runinfo,
    annotation = annotation
  )
  save(results,file=paste(folder,"/results.RData",sep=""))
  return(results)
}



